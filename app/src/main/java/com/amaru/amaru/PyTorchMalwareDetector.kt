package com.amaru.amaru

import android.content.Context
import android.util.Log
import org.pytorch.IValue
import org.pytorch.Module
import org.pytorch.Tensor
import java.io.File
import java.io.FileOutputStream

/**
 * PyTorch Malware Detector for real-time network flow analysis
 * Integrates with CICAndMal2017 dataset features (31 characteristics)
 */
class PyTorchMalwareDetector(private val context: Context) {
    
    companion object {
        private const val TAG = "PyTorchMalwareDetector"
        private const val MODEL_FILE = "full_model_mobile.pt"
        
        // Model configuration based on your training
        private const val INPUT_DIM = 31  // 31 CICAndMal2017 features
        private const val MEMORY_LENGTH = 8640  // 6 hours (2160 * 10 seconds)
        private const val SEQUENCE_LENGTH = 1  // Single sample prediction
    }
    
    private var model: Module? = null
    private var isModelLoaded = false
    
    // Persistent memory state (6 hours of network flow history)
    private var currentMemory: FloatArray? = null
    
    // Statistics
    private var totalPredictions = 0
    private var maliciousPredictions = 0
    private var averageConfidence = 0.0
    
    /**
     * Initialize and load the PyTorch model
     */
    fun initializeModel(): Boolean {
        return try {
            Log.d(TAG, "🧠 Initializing PyTorch malware detection model...")
            
            // Load model from assets
            val modelPath = assetFilePath(context, MODEL_FILE)
            model = Module.load(modelPath)
            
            // Initialize empty memory state
            initializeMemoryState()
            
            isModelLoaded = true
            Log.d(TAG, "✅ PyTorch model loaded successfully")
            Log.d(TAG, "📋 Configuration: ${INPUT_DIM} features, ${MEMORY_LENGTH} memory length")
            
            true
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error loading PyTorch model", e)
            Log.e(TAG, "💡 Make sure full_model_mobile.pt is in assets/ folder")
            false
        }
    }
    
    /**
     * Initialize memory state with zeros
     */
    private fun initializeMemoryState() {
        currentMemory = FloatArray(MEMORY_LENGTH * INPUT_DIM) { 0.0f }
        Log.d(TAG, "🔄 Memory state initialized (${MEMORY_LENGTH} x ${INPUT_DIM})")
    }
    
    /**
     * Predict malware probability for network flow statistics
     */
    fun predict(networkFlowStats: NetworkFlowStats): MalwarePredictionResult {
        if (!isModelLoaded || model == null) {
            Log.w(TAG, "⚠️ Model not loaded, returning safe prediction")
            return MalwarePredictionResult(
                isMalicious = false,
                confidence = 0.0,
                riskLevel = RiskLevel.SAFE,
                memoryUtilization = 0.0,
                modelStatus = "Model not loaded"
            )
        }
        
        return try {
            // Extract 31 features from network flow stats
            val features = networkFlowStats.toFeatureArray()
            
            if (features.size != INPUT_DIM) {
                Log.e(TAG, "❌ Feature dimension mismatch: expected $INPUT_DIM, got ${features.size}")
                return MalwarePredictionResult(
                    isMalicious = false,
                    confidence = 0.0,
                    riskLevel = RiskLevel.SAFE,
                    memoryUtilization = 0.0,
                    modelStatus = "Feature dimension error"
                )
            }
            
            // Prepare tensors for model inference
            val B = 1L  // Batch size
            
            // Current input (single sample with 31 features)
            val inputTensor = Tensor.fromBlob(
                features as FloatArray, 
                longArrayOf(B, SEQUENCE_LENGTH.toLong(), INPUT_DIM.toLong())
            )
            
            // Current memory state
            val memoryTensor = Tensor.fromBlob(
                currentMemory!! as FloatArray, 
                longArrayOf(B, MEMORY_LENGTH.toLong(), INPUT_DIM.toLong())
            )
            
            // Run inference: (memory, input_seq) -> (output, updated_memory)
            val outputTuple = model!!.forward(
                IValue.from(memoryTensor), 
                IValue.from(inputTensor)
            ).toTuple()
            
            // Extract results
            val predictionTensor = outputTuple[0].toTensor()
            val updatedMemoryTensor = outputTuple[1].toTensor()
            
            // Get prediction (logit -> probability)
            val logit = predictionTensor.dataAsFloatArray[0]
            val probability = sigmoid(logit).toDouble()
            val isMalicious = probability > 0.5
            
            // Update persistent memory for next prediction
            currentMemory = updatedMemoryTensor.dataAsFloatArray
            
            // Calculate memory utilization
            val memoryUtilization = calculateMemoryUtilization()
            
            // Determine risk level
            val riskLevel = when {
                probability > 0.9 -> RiskLevel.CRITICAL
                probability > 0.7 -> RiskLevel.HIGH
                probability > 0.5 -> RiskLevel.MEDIUM
                probability > 0.3 -> RiskLevel.LOW
                else -> RiskLevel.SAFE
            }
            
            // Update statistics
            updateStatistics(probability, isMalicious)
            
            Log.d(TAG, "🔍 Prediction: ${if (isMalicious) "MALICIOUS" else "BENIGN"} (${(probability * 100).toInt()}%)")
            
            MalwarePredictionResult(
                isMalicious = isMalicious,
                confidence = probability,
                riskLevel = riskLevel,
                memoryUtilization = memoryUtilization,
                modelStatus = "Active"
            )
            
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error during prediction", e)
            MalwarePredictionResult(
                isMalicious = false,
                confidence = 0.0,
                riskLevel = RiskLevel.SAFE,
                memoryUtilization = 0.0,
                modelStatus = "Prediction error: ${e.message}"
            )
        }
    }
    
    /**
     * Calculate memory utilization (how much of 6-hour window is used)
     */
    private fun calculateMemoryUtilization(): Double {
        return minOf(totalPredictions * 10.0 / (6 * 3600), 1.0) // 10 seconds per sample
    }
    
    /**
     * Update prediction statistics
     */
    private fun updateStatistics(confidence: Double, isMalicious: Boolean) {
        totalPredictions++
        if (isMalicious) maliciousPredictions++
        
        // Update average confidence
        averageConfidence = (averageConfidence * (totalPredictions - 1) + confidence) / totalPredictions
    }
    
    /**
     * Get current model statistics
     */
    fun getStatistics(): ModelStatistics {
        return ModelStatistics(
            totalPredictions = totalPredictions,
            maliciousPredictions = maliciousPredictions,
            averageConfidence = averageConfidence,
            memoryUtilization = calculateMemoryUtilization(),
            isModelLoaded = isModelLoaded
        )
    }
    
    /**
     * Reset memory state and statistics
     */
    fun resetState() {
        initializeMemoryState()
        totalPredictions = 0
        maliciousPredictions = 0
        averageConfidence = 0.0
        Log.d(TAG, "🔄 Model state and statistics reset")
    }
    
    /**
     * Sigmoid activation function
     */
    private fun sigmoid(x: Float): Float = 1f / (1f + kotlin.math.exp(-x))
    
    /**
     * Copy asset file to internal storage for PyTorch loading
     */
    private fun assetFilePath(context: Context, assetName: String): String {
        val file = File(context.filesDir, assetName)
        if (!file.exists()) {
            context.assets.open(assetName).use { inputStream ->
                FileOutputStream(file).use { outputStream ->
                    val buffer = ByteArray(4 * 1024)
                    var read: Int
                    while (inputStream.read(buffer).also { read = it } != -1) {
                        outputStream.write(buffer, 0, read)
                    }
                    outputStream.flush()
                }
            }
        }
        return file.absolutePath
    }
}

/**
 * Result of malware prediction using PyTorch model
 */
data class MalwarePredictionResult(
    val isMalicious: Boolean,
    val confidence: Double,
    val riskLevel: RiskLevel,
    val memoryUtilization: Double,
    val modelStatus: String
)

/**
 * Model statistics
 */
data class ModelStatistics(
    val totalPredictions: Int,
    val maliciousPredictions: Int,
    val averageConfidence: Double,
    val memoryUtilization: Double,
    val isModelLoaded: Boolean
) 